\section{Functional description}
This section defines the program's objects and their associated
operations. The style is minimal and close to the computations. For
the rationale sustaining the computation and complementary information,
see the justification section (\cref{sec:justification}).

\subsection{base}
Some base types are useful throughout the program. These are detailed in this
section.

\subsubsection{Point3}
\lstinline{Point3} are points in 3D space. They are described by $(x, y, z)$
coordinates.

\subsubsection{UVec3}
\lstinline{UVec3} are unit vectors in 3D space.

\subsection{ray}
\lstinline{ray} objects are the centerpiece of the simulation. They must be
lightweight objects.  \lstinline{ray} holds a position and a unit vector in the
direction and orientation of the propagation of light:

\begin{itemize}
\item \lstinline{Point3 p}: A point.
\item \lstinline{UVec3 v}: A vector, oriented by light propagation.
\end{itemize}

The interpretation of the data contained in a \lstinline{ray} is dependent
on context, as they are expressed in the current surface coordinate system.

In addition to their geometric definition, rays also hold a status code.
This code signals whether raytracing operations were successful, and if
not, which error case was encountered.

\begin{itemize}
\item \lstinline{int code}: Status code.
\end{itemize}

The status codes are defined in \cref{tab:ray-status-codes}.

\begin{table} \caption{\label{tab:ray-status-codes} Ray status codes.}
\begin{tabular}{| c | l |} \hline
\textbf{Code} & \textbf{Meaning} \\ \hline
0 & Success, the ray is valid.\\ \hline
1 & Sphere intersection: No intersection. \\ \hline
2 & Sphere intersection: Intersection beyond first hemisphere. \\ \hline
3 & refract: \gls{TIR} \\
\hline \end{tabular}
\end{table}

\subsection{rop}
\lstinline{rop} are ray operations.

\subsubsection{reflect}
\lstinline{reflect} is a ray operation which applies the law of specular
reflection \cite{wiki:specular-reflection}. The ray direction is modified in
place. The normal vector $\overrightarrow{N}$ is already computed. There are
no error cases. The operation is illustrated on \cref{fig:reflect}.

\begin{equation}
\begin{bmatrix} l_r \\ m_r \\ n_r \end{bmatrix} =
\begin{bmatrix} l \\ m \\ n \end{bmatrix} - 2 \cdot
\overrightarrow{N} \cdot \left( \overrightarrow{N} \cdot
\begin{bmatrix} l \\ m \\ n \end{bmatrix} \right)
\end{equation}

\begin{figure} \caption{\label{fig:reflect} reflect operation quantities.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/abstract-reflect.svg}
\end{figure}

\subsubsection{refract}
\lstinline{refract} is a ray operation applying the Snell law of refraction
\cite{wiki:snell-refraction}. The ray direction is modified in place.  We use
Xavier Bec's formula (\cite{Marrs:2021} p.105, \cite{Bec:1997}) for efficiency.
The operation is illustrated on \cref{fig:refract}.

\begin{figure} \caption{\label{fig:refract} refract operation quantities.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/abstract-refract.svg}
\end{figure}

Let,

\begin{itemize}
\item $n_1$ the incident medium refraction index,
\item $n_2$ the output medium refraction index,
\item $n_r = \frac{n_1}{n_2}$,
\item $\overrightarrow{i}$ the unit incident ray direction,
\item $\overrightarrow{N}$ the unit surface normal vector,
\item $\overrightarrow{t}$ the unit refracted ray direction.
\end{itemize}

\begin{equation}
\begin{split}
&c_1 = - \overrightarrow{i} \cdot \overrightarrow{N} \\
&w = n_r \cdot c_1 \\
&c_{2m} = (w - n_r) \cdot (w + n_r)
\end{split} \end{equation}

At this stage, if $c_{2m} < -1$, then we set the \gls{TIR} ray
error code and the computation stops. Otherwise we proceed with
the computation of the refracted ray direction.
with:

\begin{equation}
\overrightarrow{t} = n_r \cdot \overrightarrow{i} +
(w - \sqrt{1 + c_{2m}}) \cdot \overrightarrow{N}
\end{equation}

\textcolor{red}{TODO:
\begin{itemize}
\item transfer operation
\end{itemize}}

\subsection{shape}
Shapes are an abstract concept specifying two operations:

\begin{itemize}
\item \lstinline{intersect}: Intersect a ray with the shape.
\item \lstinline{normal}: Provide a normal vector at the current ray
      position.
\end{itemize}

\paragraph{intersect}
The intersection operation takes a \lstinline{ray} expressed in the current
surface coordinate system with point on the local plane. It propagates
the ray until it hits the first encountered part of the shape. It modifies
the ray in-place. The modified ray is still expressed in the same current
coordinate system. This operation is illustrated on
\cref{fig:abstract-rayinter}.

\begin{figure} \caption{\label{fig:abstract-rayinter} Illustration of the
abtract intersect operation for a shape on a ray.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/abstract-rayinter.svg}
\end{figure}

\paragraph{normal}
The normal operation provides a normal vector at the ray's current
position on the shape. The normal vector is expressed in the surface
LCS. The normal vector is a unit vector. The normal vector is oriented
with a $\hat{z}$ component of opposite sign to that of the ray's vector,
\textit{ie} the normal vector is in the opposite half-plane to the incident
ray. The normal operation is illustrated on \cref{fig:abstract-normal}. Error
cases can in theory happen due to numerical issues, they should be very rare.

\begin{figure} \caption{\label{fig:abstract-normal} Illustration of the
abstract normal operation for a shape and a ray.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/abstract-normal.svg}
\end{figure}

\subsubsection{plane}
\paragraph{Definition}
A \lstinline{plane} is the local $z=0$ plane in the current \gls{LCS}.
It is specified implicitely.

\paragraph{intersect}
The input ray is already on the local plane. We do \emph{nothing} and cannot
fail.

\paragraph{normal}
The plane normal vector is trivial.
It is $\overrightarrow{N} = (0, 0, -\textrm{sign}(n))$.
There are no error cases.

\subsubsection{sphere}

\paragraph{Definition}
The \lstinline{sphere} is specified by:

\begin{itemize}
\item $R$: radius of curvature
\end{itemize}

The sphere is defined in the \gls{LCS} by \cref{eq:sphere-def}.

\begin{equation} \label{eq:sphere-def}
x^2 + y^2 + (z - R)^2 = R^2
\end{equation}

$R$ is the signed distance $\overline{AC}$, with $C$ the sphere center
(\cref{fig:sphere-def-lcs}). Only the hemisphere closest to the local plane
is considered as part of the \lstinline{sphere} shape.

\begin{figure} \caption{\label{fig:sphere-def-lcs} Sphere definition
in the LCS. Both signs of $R$ are represented.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/sphere.svg}
\end{figure}

\textcolor{red}{TODO:
1. What happens if we define a sphere with R = 0? and for small R?
}

\paragraph{intersect}
The intersection between the input ray and the sphere is computed as
follows. The quantities involved are illustrated on \cref{fig:sphere-inter}.

\begin{figure} \caption{\label{fig:sphere-inter} Sphere intersection with
a ray diagram. The intersection point is $I$. The diagram is drawn arbitrarily
in the case $R<0$.}
\includesvg[height=.2\textheight, width=.9\textwidth, keepaspectratio]
           {images/shape/sphere-rayinter.svg}
\end{figure}

\begin{equation} \label{eq:ray-sphere-inter1}
\begin{cases}
b &= 2 (x \cdot l + y \cdot m - n \cdot R) \\
c &= x^2 + y^2 \\
\Delta &= b^2 - 4 c
\end{cases}
\end{equation}

If $\Delta \leq 0$, then no intersection exists. This is a ray error case.
Else, we continue with \cref{eq:ray-sphere-inter-tsol}.

\begin{equation} \label{eq:ray-sphere-inter-tsol}
t_\textrm{sol} = \frac{-b + \textrm{sign}(b) \cdot \sqrt{\Delta}}{2}
\end{equation}

Let $(x_I, y_I, z_I)$ the intersection point we wish to compute.

\begin{equation}
z_I = t_\textrm{sol} \cdot n
\end{equation}

If $\abs{z_I} \geq \abs{R}$, we have an intersection in the hemisphere furthest
from the local plane. This is another ray error case. Else, the remainder of
the solution can be computed.

\begin{equation} \begin{aligned}
x_I &= x + t_\textrm{sol} \cdot l \\
y_I &= y + t_\textrm{sol} \cdot m
\end{aligned} \end{equation}

\paragraph{normal}
The sphere normal vector is computed as follows. The ray rests on the previously
computed intersection point.

\begin{equation}
\overrightarrow{N} =
\frac{\textrm{sign}(n)}{R} \cdot
\begin{bmatrix} x \\ y \\ z - R \end{bmatrix}
\end{equation}

\subsection{lpart}

\subsubsection{tfr}

\subsubsection{surf}
