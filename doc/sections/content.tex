\section{Scope}
Poaky deals with tracing rays of light through optical systems,
under the laws of geometrical optics. It allows defining an optical system
with surfaces propagates rays through the system. Poaky reports the
state of rays at given optical surfaces.

The following optical design related items are left out:
\begin{itemize}
\item Phase computation: The rays are purely described by their trajectory.
\item Building objective functions and constraints: This belongs in a higher
layer which uses the states of rays to build performance criteria.
\item Optimization: This is an even higher layer than objective functions.
\item Ray-aiming: We can implement this on top of the current program.
\item User-level optical system definition: The optical system defined
      by the user does not use the same formalism as that of the current
      program.
\end{itemize}

Many concepts about raytracing have been explored in depth in a previous
work \cite{Houllier-thesis}.

\textcolor{red}{Whether ray-aiming and higher functions will be included
in the current repository or another is not yet decided.}

\section{Architecture}
The software architecture follows an object-oriented, bottom-up approach.
From the lowest level of abstraction to highest, we may describe the
major objects as follows:

\begin{itemize}
\item \lstinline{ray}: Rays are the most fundamental data object in the
program.  Each ray is represented by $(x, y, z)$ local coordinates and $(l, m,
n)$ local direction cosines.
\item \lstinline{rop} (ray operations): These are low-level operations
modifying \lstinline{rays}.  They are used by \lstinline{low-level surfaces}.
They may be common to multiple surface types. A typical example is the
Snell law.
\item \lstinline{shape}: These are geometric surface shapes. They are used
mainly for specifying intersection methods with rays, and respond to queries
about normal vector and altitude at given $(x, y)$ coordinates.
\item \lstinline{lpart} (low-level part): These are low-level objects which
are ordered in succession. These are groupings of \lstinline{rop}
which correspond to common optical design surface elements. There are two
fundamental subtypes:
\begin{itemize}
\item \lstinline{surf} (surface): This group of operations takes a ray starting
from the local surface plane and outputs rays also in the local coordinate
system at the computed positions. May inherit a \lstinline{shape}.
\item \lstinline{tfr} (transfer): These operations take rays from a starting
surface coordinate system and propagate them in straight lines to another
plane. The output rays are expressed in a new local surface plane.
\end{itemize}
\item \lstinline{bun} (ray bundles): These are arrays of \lstinline{ray}. They
include some higher level utilities such as tracking and reporting the state of
rays.
\item \lstinline{lsys} (low-level system): This is a succession of
\lstinline{lpart}.
\item \lstinline{ltrac} (low-level tracer): This object holds both a
\lstinline{lsys} and a \lstinline{bun}. It is responsible for applying
operations and reporting the state of the rays to higher parts of the program.
\end{itemize}

This architecture is summarized informally using a diagram
(\cref{fig:arch-overview}).

\begin{figure} 
\includesvg[width=.9\textwidth]{images/arch/overview/overview.svg}
\caption{\label{fig:arch-overview} Architecture overview.}
\end{figure}

\section{Definitions and conventions}
We must provide the conventions that were used. They are choices
on our part and may differ from one optical design tool to the next.

\subsection{Local coordinate system}
Each surface corresponds to an implicit \gls{LCS}.
This coordinate system may be described as containing (\cref{fig:LCS}):

\begin{itemize}
\item An apex $A$, which is the origin.
\item A local $z=0$ plane, which we often refer to as the \emph{local plane}.
\item A set of axes (implicit).
\end{itemize}

\begin{figure} \caption{\label{fig:LCS} LCS diagram.}
\includesvg[width=.7\textwidth]{images/conventions/LCS.svg}
\end{figure}

We call the \gls{LCS} implicit because the actual meaning of the data
expressed in it depends on the interplay between surface defition, ray
transfer equations and ray operation conventions.

\subsection{Rays in local coordinate systems}
\textcolor{red}{TODO:
1. Implicit position definition.
2. Orientation with light propagation.}

\subsection{Ray transfer conventions}
\textcolor{red}{TODO:
1. Rays always on the local plane when transfered to the next surface.
2. Rays can be wherever in the LCS at before being transfered.}

\section{Functional description}

\textcolor{red}{TODO: \begin{itemize}
\item Detail the behavior of a minimal set of components for
only 3D mirrors.
\end{itemize}}

\subsection{base}
Some base types are useful throughout the program. These are detailed in this
section.

\subsubsection{Point3}
\lstinline{Point3} are points in 3D space. They are described by $(x, y, z)$
coordinates.

\subsubsection{UVec3}
\lstinline{UVec3} are unit vectors in the direction of the propagation
of light. These may also be refined to as \emph{direction cosines},
as their components are $(l, m, n)$.

\textcolor{red}{Give some formulae.}

\subsection{ray}
\lstinline{ray} objects are the centerpiece of the simulation. They must be
lightweight objects.  \lstinline{ray} holds a position and a unit vector in the
direction and orientation of the propagation of light:

\begin{itemize}
\item \lstinline{Point3 p}: A point.
\item \lstinline{UVec3 v}: A vector, oriented by light propagation.
\end{itemize}

The interpretation of the data contained in a \lstinline{ray} is dependent
on context, as they are expressed in the current surface coordinate system.

\textcolor{red}{Error codes for each ray?}

\subsection{rop}

\textcolor{red}{
\begin{itemize}
\item transfer operation
\item reflection off mirrors
\end{itemize}
Explain rationale to have the most specialized operations possible here.
And why operations are dissociated from lpart.}

\subsection{shape}
\lstinline{shape} objects specify an intersection operation with rays.
The intersection operation takes a \lstinline{ray} expressed in the current
surface coordinate system with point on the local plane. It propagates
the ray until it hits the first encountered part of the shape. It modifies
the ray in-place. The modified ray is still expressed in the same current
coordinate system.

Subtypes are defined.

\textcolor{red}{\begin{itemize}
\item ray/plane intersection
\item ray/sphere intersection
\item sphere normal vector
\end{itemize}}

\subsubsection{plane}
A \lstinline{plane} is the local $z=0$ plane in the current coordinate system.
It is specified implicitely.  The input ray is already on the local plane. We
do \emph{nothing} and cannot fail.

\subsubsection{sphere}

\paragraph{Definition}
The \lstinline{sphere} is specified by:

\begin{itemize}
\item $R$: radius of curvature
\end{itemize}

The sphere is defined in the \gls{LCS} by \cref{eq:sphere-def}.

\begin{equation} \label{eq:sphere-def}
x^2 + y^2 + (z - R)^2 = R^2
\end{equation}

$R$ is the signed distance $\overline{AC}$, with $C$ the sphere center
(\cref{fig:sphere-def-lcs}).

\begin{figure} \caption{\label{fig:sphere-def-lcs} Sphere definition
in the LCS.}
\includesvg[width=0.6\textwidth]{images/placeholder.svg}
\end{figure}

\textcolor{red}{TODO:
1. Diagram of sphere in local coordinate system.
2. What happens if we define a sphere with R = 0? and for small R?
}

\paragraph{intersect}
The intersection between the input ray and the sphere is computed as
follows.

\begin{equation} \label{eq:ray-sphere-inter1}
\begin{cases}
b &= 2 (x \cdot l + y \cdot m - n \cdot R) \\
c &= x^2 + y^2 \\
\Delta &= b^2 - 4 c
\end{cases}
\end{equation}

If $\Delta < 0$, then no intersection exists. This is a ray error case. Else,
we continue with \cref{eq:ray-sphere-inter-tsol}.

\begin{equation} \label{eq:ray-sphere-inter-tsol}
t_\textrm{sol} = \frac{-b + \textrm{sign}(b) \cdot \sqrt{\Delta}}{2}
\end{equation}

With:

\begin{equation}
\textrm{sign}(x) = \begin{cases}
1 & \text{if } x \geq 0 \\
-1 & \text{otherwise}
\end{cases}
\end{equation}

Let $(x_I, y_I, z_I)$ the intersection point we wish to compute.

\begin{equation}
z_I = t_\textrm{sol} \cdot n
\end{equation}

If $z_I \geq \abs{R}$, we have an intersection in the hemisphere furthest from
the local plane. This is another ray error case. Else, the remainder of the
solution can be computed.

\begin{equation}
\begin{aligned}
x_I &= x + t_\textrm{sol} \cdot l \\
y_I &= y + t_\textrm{sol} \cdot m
\end{aligned}
\end{equation}

\subsection{lpart}

\subsubsection{tfr}

\subsubsection{surf}
\textcolor{red}{
\begin{itemize}
\item Plane (which does nothing)
\item Plane mirror
\item Spherical mirror
\end{itemize}}

\section{Proofs and justification}
Some implementation detail require further justification and explanations.

\subsection{Ray intersection with a sphere}
\textcolor{red}{TODO:
1. What about b = 0 case? Document (already solved in notes).
2. Put a diagram for defining the quantities.
3. Illustrate the error cases with diagrams.
4. Show orientation of ray has no impact on intersection.}

\section{Tests and benchmarks}
We document what tests are performed on the components of the software.
We also detail a representative performance report.

\subsection{Tests}
\textcolor{red}{TODO:
* Visualize test cases in jupyter notebooks? For instance, ensure that
  a sphere intersection lands on the sphere visually.}

\subsection{Performance report}
A performance report helps both the user and developer understand the strengths
and weaknesses of the software computations.
